#include <iostream>
#include <string>
#include <algorithm> // Для reverse

using namespace std;


// Функция для проверки корректности ввода числа
string validate(const string& num) {
    for (char c : num) {                                       // Цикл for (char c : num) проходит по всем символам, (переменная  С) в строке num.
        if (!isdigit(c)) {                                     // Проверка является ли симол цифрой
            cout << "Некорректный ввод. Попробуйте снова. ( Ваше число должно состоять из цифр от 0 до 9) \n";
            return "-1";
        }
    }
    return num;
}

// Функция для сложения двух длинных чисел, представленных строками
string LargeN(string num1, string num2) {
    // Убедимся, что num1 длиннее, иначе поменяем местами. Для удобства вычислений по праилам математики 
    if (num1.length() < num2.length())
        swap(num1, num2);

    string result;       //  Результат сложения
    int cy = 0;       // Перенос в следующий разряд ( если сумма цифр больше 9)

    // Переворачиваем строки для удобства сложения с младших разрядов
    reverse(num1.begin(), num1.end());
    reverse(num2.begin(), num2.end());

    // Складываем цифры чисел
    for (size_t i = 0; i < num1.length(); ++i) { //  для итерации по индексам строки
        int dig1 = num1[i] - '0'; // Текущая цифра из num1
        int dig2 = (i < num2.length()) ? num2[i] - '0' : 0; // Цифра из num2 или 0 //  Если индекс i меньше длины num2, берется соответствующая цифра, иначе используется 0.

        int sum = dig1 + dig2 + cy; // Сумма цифр с переносом
        cy = sum / 10;                  // Новый перенос // Вычисляется новый перенос (если сумма больше 9).
        result += (sum % 10) + '0';       // Добавляем текущую цифру в результат
    }

    //Если остался перенос, добавляем его // После завершения цикла проверяется, остался ли перенос. Если да, то он добавляется к результату.
    if (cy > 0)
        result += cy + '0';

    // Возвращаем строку в исходный порядок 
    // Результат переворачивается обратно в исходный порядок.
    reverse(result.begin(), result.end());
    return result;
}

// Функция для умножения длинного числа на однозначное число
string multN(string num, int dig) {
    string result; // Результат умножения
    int cy = 0; // Перенос в следующий разряд ( если сумма цифр больше 9)

    reverse(num.begin(), num.end()); //    Переворот числа для удобства вычисления

    for (char c : num) {                                                    //Цикл for (char c : num) проходит по всем символам (переменная  С) в перевернутой строке num.
        int prod = (c - '0') * dig + cy; // Уможаем цифру разряда на 2 
        cy = prod / 10; // Новый перенос
        result += (prod % 10) + '0';
    }

    // Если остался перенос, добавляем его
    if (cy > 0)
        result += cy + '0';

    // Возвращаем строку в исходный порядок
    reverse(result.begin(), result.end());
    return result;
}

// Функция для вычитания двух длинных чисел
string LargeNum(string num1, string num2) {

    bool negat = false;

    // Убедимся, что num1 длиннее, иначе поменяем местами
    if (num1.length() < num2.length() || (num1.length() == num2.length() && num1 < num2)) {  // Функция сначала проверяет, является ли num1 меньше num2. 
        // Если это так, она меняет их местами и устанавливает флаг negat в true, 
        // Чтобы обозначить, что результат будет отрицательным.
        swap(num1, num2);
        negat = true;
    }

    string result;   // Результат разности
    int cy = 0;   // Перенос в следующий разряд ( если сумма цифр больше 9)


    // Переворачиваем строки для удобства вычитания с младших разрядов
    reverse(num1.begin(), num1.end());
    reverse(num2.begin(), num2.end());

    // Вычитаем цифры чисел
    for (size_t i = 0; i < num1.length(); ++i) {     //  используется для итерации по индексам строки
        int dig1 = num1[i] - '0'; // Текущая цифра из num1
        int dig2 = (i < num2.length()) ? num2[i] - '0' : 0; // Цифра из num2 или 0 + тернарный оператор 

        int diff = dig1 - dig2 - cy;  // Разность цифр с переносом

        // для переноса цифр в следующие разряды
        if (diff < 0) {                     //  Если разность оказывается отрицательной, 
            diff += 10;                     //  добавляет 10 к разности
            cy = 1;                      //  устанавливает перенос в 1
        }
        else {
            cy = 0;
        }

        result += diff + '0';
    }
    // Удаление всех нулей ('0') из конца строки result 
    // Для нормализации строки, чтобы убрать лишние нули в конце.
    while (result.size() > 1 && result.back() == '0')
        result.pop_back();

    // реверсирование cтроки
    reverse(result.begin(), result.end());

    return (negat ? "-" : "") + result; // возврат числа с учётом знака, если оно будет отрицательным  
    // + тернарный оператор -  если условие выполнено то с - если нет, то + то есть пустая строка 
}
